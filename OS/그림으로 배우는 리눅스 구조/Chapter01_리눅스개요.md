### 프로그램과 프로세스

- 프로그램 : 컴퓨터에서 동작하는 관련된 명령 및 데이터를 하나로 묶은 것
    - 컴파일러형 언어(C/C++, Go ..)라면 빌드해서 만들어진 실행 파일(executable file)을 프로그램이라고 부른다
    - 스크립형 언어(Python, JavaScript ..)라면 소스 코드 그 자체가 프로그램
    - 커널(Kernel)도 프로그램의 일종
- 리눅스에서 동작하는 프로그램
    - 웹브라우저 : Chrome, Firefox
    - 오피스 프로그램
    - 웹서버 : Apache, Nginx
    - 텍스트 에디터 : Vim ..
    - 프로그래밍 언어 관련 : C, Go Compiler, Python Interpreter …
    - 쉘 : bash, zsh …
    - 시스템 전체 관리 소프트웨어 : systemd …
- 프로세스 : 실행되어서 동작 중인 프로그램

### 커널


![image-15](https://github.com/user-attachments/assets/5b915041-64b5-4a37-835b-35cf8e0888b7)   
현재 그림에서는 프로세스가 한 개이지만, 여러 프로세스가 동시에 장치를 제어하려고 하면 문제가 발생한다. (`경쟁 상태 : Race Condition`)

예를 들어, 중간 다른 프로세스가 끼어드는 상황이 발생하면 데이터의 무결성이 손상된다.

(데이터 무결성 : 여러 프로세스가 동시에 데이터를 읽거나 쓰는 경우, 데이터가 손상. 예를 들어, 한 프로세스가 데이터를 읽는 동안 다른 프로세스가 데이터를 변경하면, 읽은 데이터가 올바르지 않을 수 있다.)

이렇게 직접 저장 장치에 접근한다면 명령 실행 순서를 올바르게 제어하지 않으면 위험하다. 이런 문제 말고도 접근 불가능이어야 할 프로그램이 장치에 접근 가능한 문제도 생길 수 있다. 

결국 **커널**이 프로세스가 장치(하드웨어)에 직접할 수 없도록 한다.(CPU에 내장된 모드 사용)

- CPU 모드
    - `커널 모드` : 제약 x (커널만이 커널 모드로 동작해서 장치 접근 가능)
    - `사용자 모드` : 특정 명령어 실행하지 못하는 제약 o(사용자 공간에서 프로세스 실행)

### 시스템 콜

- 시스템 콜(System Call) : 프로세스가 커널에 처리를 요청하는 방법
    - 프로세스 생성 및 삭제
    - 메모리 확보 및 해제
    - 통신 처리
    - 파일 시스템 조작
    - 장치 조작
  
![1_syscall](https://github.com/user-attachments/assets/1f548b4f-e434-4c5c-b3c9-77486e3bcc20)

시스템 콜은 CPU의 특수한 명령을 실행해서 처리된다. 프로세스는 사용자 모드(User mode)로 실행되지만 커널에 처리를 요청하기 위해 시스템 콜을 호출하면 CPU에서는 예외(exception) 이벤트가 발생한다. 

이벤트가 발생하면 CPU 모드는 사용자 → 커널로 변경되어서 요청 내용에 따라 커널 처리가 동작한다. 처리가 끝나면 커널 → 사용자로 변경되어서 프로세스 동작이 이어진다. 

커널은 올바른 요청인지 확인하고 올바른 요청이 아니라면 시스템 콜은 실패하게 된다. 위 그림에서와 같이 시스템 콜을 통하지 않고 프로세스에서 CPU 모드를 변경하는 방법은 없다.

- 왜 그런 것일까?
    - 프로세스에서 CPU모드를 변경해서 직접 장치를 조작한다면 데이터 유출이라는 큰 문제가 발생할 수 있다.
    - 그래서 새로운 앱을 다운받으면 권환 허용 유무 알림이 뜨는 것이구나!

**시스템 콜 호출 확인**

먼저 Go 언어로 확인해보자.(Go 언어를 처음 사용해보는데 이번 기회에 배워봐야겠다!)

```go
// hello.go

package main

import (
	"fmt"
)

func main() {
	fmt.Println("hello world")
}
```

```bash
go build hello.go
./hello

# 결과
hello world
```

`strace`를 사용해서 프로그램이 어떤 시스템 콜을 호출하는 지 확인할 수 있다.( -o 옵션은 파일로 저장)

```bash
# 결과 출력 및 hello.log에 저장
strace -o hello.log ./hello

# 시스템 콜 확인(log 파일)
cat hello.log
```

`strace` 출력 각각의 줄이 1개의 시스템 콜 호출로 마지막 문장은 `write(1, “hello world\n”, 12) = 12` ****가 나왔다. (write 시스템 콜 호출)

Python으로 확인해보자.

```python
# hello.py
print("hello world")
```

```bash
# 파일 권한 
chmod +x hello.py

# 결과 출력 및 hello.py.log에 저장
strace -o hello.py.log python3 ./hello.py

# 시스템 콜 확인(log 파일)
cat hello.py.log
```

Go언어로 했을 때와 동일하게 마지막은 write 시스템콜 호출로 끝나는데 전체결과를 확인해보면 스크립트형 언어다 보니 확실히 Go언어보다 많은 시스템 콜을 호출하는 것을 확인할 수 있었다.(많은 문장 출력)

**시스템 콜을 처리하는 시간 비율**

```bash
sar -P 0 1 1
```

`sar` : CPU가 실행하고 있는 명령 비율 확인

-P 0 : CPU 코어 0이 어떤 종류 처리를 하는지 확인

1 : 1초

1 : 1번 데이터 수집

해당 명령어를 수행하면 다양한 필드의 값들을 표시한다. 

- %user + %nice : 사용자 모드에서 프로세스를 실행하는 시간 비율
- %system : 커널이 시스템 콜을 처리한 시간 비율
- %idle : 아무 것도 하지 않는 idel 상태 비율

taskset 명령어를 이용해서 inf-loop.py(무한루프) 프로그램을 CPU 0에서 동작해보자.

```python
import os

# 부모 프로세스의 프로세스 ID 얻기
while True:
	os.getppid()
```

```bash
taskset -c 0 python3 ./inf-loop.py &

sar -P 0 1 1
```

해당 명령어를 수행하면 %user(48%)와 %system(52%)이 대략 절반씩 차지하며 %idle은 0이 된 것을 확인할 수 있다. 결국 끊임없이 시스템 콜을 호출해서 %system이 큰 비율을 차지함을 알 수 있다. 

(user → kernel → user → kernel …)

### 모니터링, 경고 알림 및 대시보드

시스템이 예상한 대로 동작하는지 확인하려면 `sar` 명령어를 비롯한 도구를 사용해서 시스템 통계 정보를 수집하는 것이 중요하다. 

- 수집, 관리하는 구조를 `모니터링(monitoring)` 이라고 부른다.(프로메테우스, 데이터독..)
- 계속해서 사람이 통계 정보를 직접 확인하는 것은 어렵기 때문에 일반적으로 어떤 상태가 정상인지 미리 정의해두고 이상이 발생하면 관리자에게 알려주는 `알림(alert)` 기능을 모니터링 도구와 함께 사용한다.
- 수집한 데이터를 가시화해서 확인 가능한 `대시보드` 기능도 함께 사용한다.(Grafana Dashboard .. )

현재 EATceed 프로젝트를 진행하고 있어 모니터링 기능을 추가하려고 하는데, 모니터링 기능에 기반이 되는 `sar` 명령어를 학습해서 기본적인 이해가 높아진 것 같다.

### 라이브러리

여러 프로그래밍 언어에는 다수의 프로그램에서 공통으로 사용하는 처리를 라이브러리로 합쳐서 제공하는 기능이 존재한다. 이걸 사용해서 미리 만들어진 대량의 라이브러리에서 필요한 걸 골라서 효율적으로 프로그램을 개발할 수 있다. 

**표준 C 라이브러리**

- C언어로 작성된 대부분의 C 프로그램은 `libc` (C library)를 링크한다.
- 프로그램이 어떤 라이브러리를 링크하는지 알아보려면 `ldd` 명령어 사용

```bash
ldd /usr/bin/python3
```

- 파이썬을 실행하는 python3 명령어를 확인해보면 파이썬 명령어 또한 `libc` 를 링크하고 있다.
- 결국, 파이썬 프로그램을 실행할 때 내부적으로는 표준 C 라이브러리를 사용한다는 것!
    - **요즘 C언어를 안 사용한다고하지만 결국에 내부를 뜯어보면 C언어는 아주 중요하다는 것을 의미한다.**

**시스템 콜 래퍼 함수**

`libc` 는 시스템 콜 래퍼(wrapper) 함수도 제공한다. 시스템 콜은 일반 함수 호출과 다르게 C언어 같은 고급 언어에서 직접 호출할 수 없다.(어셈블리 코드 필요!)

`libc` 의 시스템 콜 래퍼 함수가 시스템 콜을 호출해준 덕분에 시스템 콜을 호출할 때 마다 아키텍처 의존 어셈블리 코드를 작성해줄 필요가 없어졌다. 

- **정리하자면 고급 언어(우리가 알고있는 사용자 친화적)로 작성된 프로그램을 시스템 콜 래퍼 함수가 해석해서 커널에 접근해준다고 이해하자!**
<br/></br>  

**정적 라이브러리와 공유 라이브러리**

라이브러리 종류는 다음과 같다.

- 정적 라이브러리
- 공유(동적) 라이브러리

두 개의 차이점은 무엇일까? `프로그램과 결합하는 방식의 차이` 

- 프로그램 생성(빌드) 방식
    - 소스코드 컴파일(.c) → 오브젝트 파일 생성(.o) → **라이브러리 링크(.a)** → 실행파일(.exe) 생성
- 라이브러리 링크 방식
    - 정적 라이브러리는 링크할 때 라이브러리에 있는 함수를 프로그램에 집어넣기
    - 공유(동적) 라이브러리는 ‘어떤 함수를 호출해야한다’라는 정보만 실행파일에 포함, 프로그램이 실행 중에 라이브러리를 메모리에 로드하고 프로그램이 그 안에 있는 함수를 호출
- **정리하자면 정적은 처음부터 넣어두고있고, 공유(동적)은 프로그램을 실행할 때 로드해서 사용한다는 것이다!**


```c
// pause.c

int main(void) {
	pause();
	return 0;
}
```

코드를 실행하고 다음 관점에서 확인을 할 필요가 있다.

- 파일 크기
- 공유 라이브러리와 링크 상태

**pause.c 실행 후 확인(정적 라이브러리 사용) → libc.a 사용**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c79766f-e6e5-47fb-bb1f-6711656123dd/be51aa33-683b-434d-bc98-16d5a7d2db4b/Untitled.png)

- 파일 크기 : 약 650KiB
- 공유 라이브러리 링크 x

**pause.c 실행 후 확인(동적 라이브러리 사용) → libc.so 사용**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c79766f-e6e5-47fb-bb1f-6711656123dd/4d6a14b3-8f46-4145-8cc5-9dea5d1d925f/Untitled.png)

- 파일 크기 : 약 16KiB
- 공유 라이브러리 링크 o

두 개의 실행결과를 확인해보면 동적 라이브러리를 사용했을 때 확연히 파일 크기가 작은 것을 알 수 있다. 앞에서 설명했듯이 `libc`가 프로그램 자체에 포함되는 게 아니라 실행 시 메모리에 로드되기 때문이다. 

공유 라이브러리를 사용하는 이유를 정리하면 다음과 같다.

- **시스템에서 차지하는 파일 크기 줄이기**
- **라이브러리에 문제가 있을 때 공유 라이브러리를 수정만 하면 라이브러리에 관한 문제를 해결할 수 있다.**

여기까지 학습을 하면 “**그럼 동적 링크가 항상 옳네?**”라고 생각할 수 있다. 근데 최신에는 상황이 달라졌다고 언급이 있다.

**정적 링크가 돌아왔다**

최근에 인기가 좋은 Go언어는 기본적으로 라이브러리를 모두 정적 링크한다. 이 말은 즉슨 일반적인 Go 프로그램은 어떤 공유 라이브러리에도 의존하지 않는다는 것이다. 

```go
// hello.go : ldd 확인
ldd hello
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c79766f-e6e5-47fb-bb1f-6711656123dd/770344fa-cd57-448d-9512-19571138e9e0/Untitled.png)

`ldd` 로 확인해본결과 Go는 동적 링크를 사용하고 있지 않음을 알 수 있다. 

**그럼 왜 최신에 유행하고 있는 Go 언어는 앞서 배운 장점을 가진 동적 링크가 아닌 정적 링크를 사용하는 것일까?**

- 대용량 메모리나 저장장치가 발전해서 **파일 크기는 상대적으로 별 문제** x
- 실행 파일 하나로 프로그램이 동작한다면 해당 파일만 복사하면 **다른 환경에서도 동작하므로 사용이 편리**
- 실행할 때 공유 라이브러리를 링크하지 않아도 되어서 **시작 시간이 빠름**
- 공유 라이브러리의 **DLL 지옥문제(버전업에 따른 문제) 회피 가능**