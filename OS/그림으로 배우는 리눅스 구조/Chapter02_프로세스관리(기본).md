## 프로세스 생성

### 프로세스 확인

```bash
# 모든 프로세스 확인
ps aux
```

해당 명령어를 실행하면 PID, %CPU, %MEM 등 프로세스에 관한 정보를 얻을 수 있다. 

단순하게 프로세스의 개수를 알고 싶다면?

```bash
ps aux --no-header | wc -l
```

### 프로세스 생성

새로운 프로세스를 생성하는 목적은 다음 두 가지 경우이다.

- 동일한 프로그램 처리를 여러 프로세스에 나눠서 처리(웹서버에서 다수의 요청 받기)
- 다른 프로그램 생성(bash에서 각종 프로그램 새로 생성)

*첫 번째 경우는 저번 학기에 배운 [운영체제 과제](https://github.com/Kyeong6/operating-system/blob/main/assignment01/README.md)에서 수행하였다.  멀티 프로세스를 구현해서 요청에 대해 일대일 대응을 시키는 과제였다.* 

프로세스 생성을 실제로 실행하는 방법은 fork(), execve() 함수를 사용하는 것이다.

해당 함수는 내부적으로 각각 clone(), execve() 시스템콜을 호출한다. (저번 글에서의 이해가 필요하다. 함수 → 시스템 콜 → 커널)

첫 번째 경우는 fork()만, 두 번째 경우는 fork(), execve()를 모두 사용한다. 

**fork() 함수 : 자식 만들기**

fork() 함수는 간단하게 복사본을 만든다고 생각하면 된다. 원본이 부모(parent process), 복사본이 자식(child process)라고 부른다. 

- 실행 순서
    - 부모 프로세스가 fork() 함수 호출
    - 자식의 메모리 영역 확보한 후 부모 프로세스 메모리 복사
    - 부모와 자식 둘 다 fork() 함수에서 복귀(실행 끝 의미: 반환값 생성)
    - 부모와 자식은 반환값이 서로 달라서 분기 처리가 가능

*운영체제 과목에서 fork에 관하여 학습을 해서 다 알고있는 내용인 줄 알았는데 실행 순서(fork() 함수 복귀 …)에 관해서 이번 기회에 더 자세하게 배웠다. 다시 생각해보면 부모와 자식이 fork() 함수에서 복귀한다는 의미는 당연한 것이다. 역할이 끝났기 때문!*

*또한 프로세스 메모리를 복사하는 작업은 추후에 배울 내용이지만 카피 온 라이트 기능 덕분에 매우 적은 비용이라는 것이다. 그래서 **결과적으로 멀티 프로세스를 구현해도 오버헤드가 적지 않다는 것!***

**fork() 실습 진행**

```python
# fork.py

import os, sys

ret = os.fork()

if ret == 0:
	print("Child process pid={}, Parent process pid={}".format(os.getpid(), os.getppid())
	exit()
	
elif ret > 0:
	print("Parent process pid={}, Child process pid={}".format(os.getpid(), ret))
	exit()
	
sys.exit(1)
```

해당 스크립트를 생성하고 python3 ./fork.py를  수행하면 다음과 같은 결과를 얻는다.

<img width="497" alt="스크린샷 2024-08-06 오후 5 47 39" src="https://github.com/user-attachments/assets/7f45d736-58bc-4b2f-a669-d44e27bbf7e0">


정리하자면 fork() 함수에서 복귀한 후 반환값에 조건이 달라진다.

- 부모 프로세스 : 자식 프로세스의 ID 반환(ret > 0 조건)
- 자식 프로세스 : 0을 반환(ret == 0 조건)
  
<br/></br>
**execve() 함수 : 다른 프로그램을 기동**

fork() 함수로 프로세스 복사본을 만들었으면 자식 프로세스에서 execve() 함수를 호출하여 새로운 프로그램으로 바꾼다.

- 실행 순서
    - execve() 함수 호출
    - execve() 함수 인수로 지정한 실행 파일에서 프로그램을 읽어서 메모리에 배치하는데 필요한 정보 가져옴
    - 현재 프로세스의 메모리를 새로운 프로세스 데이터로 덮어씀
    - 프로세스를 새로운 프로세스의 최초에 실행할 명령(entry point)부터 실행 시작

(현재 프로세스 메모리 → execve() 실행 → 실행 파일의 새로운 프로세스 메모리 → 시작)

*fork() 함수를 호출한 후에 자식 프로세스는 execve() 함수에 의해서 인수로 지정한 프로세스로 변경된다는 의미! 이 구조를 fork-exec 구조라 한다.*

**execve() 실습 진행**

```python
# fork-and-exec.py

import os, sys

ret = os.fork()

if ret == 0:
	print("Child process pid={}, Parent process pid={}".format(os.getpid(), os.getppid())
	os.execve("/bin/echo", ["echo", "pid={} hi"].format(os.getpid())], {})
	exit()
	
elif ret > 0:
	print("Parent process pid={}, Child process pid={}".format(os.getpid(), ret))
	exit()
	
sys.exit(1)
```

해당 스크립트를 생성하고 python3 ./fork-and-exec.py를  수행하면 다음과 같은 결과를 얻는다.

<img width="551" alt="스크린샷 2024-08-07 오후 5 35 31" src="https://github.com/user-attachments/assets/581f079e-7cdc-4567-a9e0-390b7e28bd68">


execve() 명령어로 인해서 hi가 나온 것을 알 수 있다. 결국 자식 프로세스 메모리에 echo 메모리가 바뀐 것이다.

execve() 함수가 동작하려면 실행 파일은 프로그램 코드와 데이터 이외에도 추가적인 데이터가 필요하다.

- 코드 영역의 파일 오프셋, 크기 및 메모리 맵 시작 주소
- 데이터 영역의 파일 오프셋, 크기 및 메모리 맵 시작 주소
- 최초로 실행할 명령의 메모리 주소(엔트리 포인트)

*이 부분은 저번 학기에 배운 운영체제 과목에서 배운 내용으로 이해를 했다.*

- 코드 영역:
    - 파일 오프셋 : 실행할 파일의 코드(기계어) 파일 내에서 시작하는 위치로 운영체제가 해당 정보를 사용해서 실행 파일에서 코드 영역을 추출
    - 크기 : 메모리에 얼마나 많은 공간을 할당해야하는 지 결정
    - 메모리 맵 시작 주소 : 코드 영역이 메모리에서 위치할 주소
- 데이터 영역:
    - 파일 오프셋 : 데이터 영역(전역 변수, 초기화된 데이터 ..) 파일 내에서 시작하는 위치로 운영체제가 해당 정보를 사용해서 데이터 영역을 파일에서 추출
    - 크기 : 메모리에 얼마나 많은 공간을 할당해야하는 지 결정
    - 메모리 맵 시작 주소 : 데이터 영역이 메모리에서 위치할 주소
- 엔트리 포인트:
    - 프로그램이 처음 실행될 때 최초로 실행될 명령어의 메모리 주소
    - 운영체제가 해당 함수로 프로그램을 실행할 때 엔트리 포인트 정보 사용

*결국 코드, 데이터 영역에 있는 정보를 추출 및 확인한 후 메모리에 올리는 과정이라고 할 수 있다.*

## 프로세스의 부모 자식 관계

프로세스를 새로 생성하려면 부모 프로세스가 자식 프로세스를 생성해야한다. 

그러면 최종적으로 어디까지 뻗어나가는 것일까?(Tree의 끝은 어디지?)

**컴퓨터 전원 ON하면 다음과 같은 순서로 시스템 초기화 진행**

1. 컴퓨터 전원 ON
2. BIOS or UEFI 같은 펌웨어를 기동하고 하드웨어 초기화
3. 펌웨어가 GRUB 같은 Boot Loader 기동
4. Boot Loader가 OS 커널 기동
5. OS 커널이 init 프로세스(수업시간에는 조상 프로세스로 배움)기동
6. init 프로세스가 자식 프로세를 기동하고 연쇄적으로 기동해서 프로세스 트리 구조 생성

과정을 정리하면 다음과 같다.

펌웨어 → Boot Loader → OS 커널 → init 프로세스 → 자식 프로세스 …

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c79766f-e6e5-47fb-bb1f-6711656123dd/bb1c852d-bbca-4791-9240-40c59c64e5f8/Untitled.png)

systemd(1)이 init 프로세스를 의미한다.

## 프로세스의 상태

pstree -p 명령어로 확인해봤듯이 시스템에는 수많은 프로세스가 존재한다. 그러면 프로세스들은 계속해서 CPU를 사용할까? 

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/0c79766f-e6e5-47fb-bb1f-6711656123dd/d171b0d6-54cf-4c31-94b0-9d684a3e4382/Untitled.png)

각 프로세스는 실행된 후 이벤트가 발생할 때까지 CPU를 사용하지 않고 sleep 상태로 기다리고 있다. 

예를 들면 bash 프로세스 같은 경우 사용자 입력이 있을 때까지 할 일이 없으므로 사용자 입력을 기다린다. 이 경우가 sleep 상태이다. 

위에서 STAT 속성을 정리하면 다음과 같다.

- S : sleep 상태
- R : running 상태
- Z : zombie 상태

만약 시스템의 모든 프로세스가 슬립 상태라면 논리 CPU는 idle process라고 하는 ‘아무 일도 하지 않는’ 특수한 프로세스를 동작시킨다. 

CPU 특수 명령을 사용해서 논리 CPU를 휴식 상태로 전환하고, 하나 이상의 프로세스가 실행 가능 상태가 될때까지 소비 전력을 억제하면서 대기한다. 

*노트북이나 스마트폰이 아무것도 실행이 되지 않으면 배터리가 오래가는데 이때 CPU가 사용되지 않으니까 idle process가 동작하는 원리구나!*
