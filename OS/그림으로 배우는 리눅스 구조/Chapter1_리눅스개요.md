### 프로그램과 프로세스

- 프로그램 : 컴퓨터에서 동작하는 관련된 명령 및 데이터를 하나로 묶은 것
    - 컴파일러형 언어(C/C++, Go ..)라면 빌드해서 만들어진 실행 파일(executable file)을 프로그램이라고 부른다
    - 스크립형 언어(Python, JavaScript ..)라면 소스 코드 그 자체가 프로그램
    - 커널(Kernel)도 프로그램의 일종
- 리눅스에서 동작하는 프로그램
    - 웹브라우저 : Chrome, Firefox
    - 오피스 프로그램
    - 웹서버 : Apache, Nginx
    - 텍스트 에디터 : Vim ..
    - 프로그래밍 언어 관련 : C, Go Compiler, Python Interpreter …
    - 쉘 : bash, zsh …
    - 시스템 전체 관리 소프트웨어 : systemd …
- 프로세스 : 실행되어서 동작 중인 프로그램

### 커널


![alt text](../images/1_kernel.webp)
현재 그림에서는 프로세스가 한 개이지만, 여러 프로세스가 동시에 장치를 제어하려고 하면 문제가 발생한다. (`경쟁 상태 : Race Condition`)

예를 들어, 중간 다른 프로세스가 끼어드는 상황이 발생하면 데이터의 무결성이 손상된다.

(데이터 무결성 : 여러 프로세스가 동시에 데이터를 읽거나 쓰는 경우, 데이터가 손상. 예를 들어, 한 프로세스가 데이터를 읽는 동안 다른 프로세스가 데이터를 변경하면, 읽은 데이터가 올바르지 않을 수 있다.)

이렇게 직접 저장 장치에 접근한다면 명령 실행 순서를 올바르게 제어하지 않으면 위험하다. 이런 문제 말고도 접근 불가능이어야 할 프로그램이 장치에 접근 가능한 문제도 생길 수 있다. 

결국 **커널**이 프로세스가 장치(하드웨어)에 직접할 수 없도록 한다.(CPU에 내장된 모드 사용)

- CPU 모드
    - `커널 모드` : 제약 x (커널만이 커널 모드로 동작해서 장치 접근 가능)
    - `사용자 모드` : 특정 명령어 실행하지 못하는 제약 o(사용자 공간에서 프로세스 실행)

### 시스템 콜

- 시스템 콜(System Call) : 프로세스가 커널에 처리를 요청하는 방법
    - 프로세스 생성 및 삭제
    - 메모리 확보 및 해제
    - 통신 처리
    - 파일 시스템 조작
    - 장치 조작
  
![syscall](../images/2_syscall.png)

시스템 콜은 CPU의 특수한 명령을 실행해서 처리된다. 프로세스는 사용자 모드(User mode)로 실행되지만 커널에 처리를 요청하기 위해 시스템 콜을 호출하면 CPU에서는 예외(exception) 이벤트가 발생한다. 

이벤트가 발생하면 CPU 모드는 사용자 → 커널로 변경되어서 요청 내용에 따라 커널 처리가 동작한다. 처리가 끝나면 커널 → 사용자로 변경되어서 프로세스 동작이 이어진다. 

커널은 올바른 요청인지 확인하고 올바른 요청이 아니라면 시스템 콜은 실패하게 된다. 위 그림에서와 같이 시스템 콜을 통하지 않고 프로세스에서 CPU 모드를 변경하는 방법은 없다.

- 왜 그런 것일까?
    - 프로세스에서 CPU모드를 변경해서 직접 장치를 조작한다면 데이터 유출이라는 큰 문제가 발생할 수 있다.
    - 그래서 새로운 앱을 다운받으면 권환 허용 유무 알림이 뜨는 것이구나!

**시스템 콜 호출 확인**

먼저 Go 언어로 확인해보자.(Go 언어를 처음 사용해보는데 이번 기회에 배워봐야겠다!)

```go
// hello.go

package main

import (
	"fmt"
)

func main() {
	fmt.Println("hello world")
}
```

```bash
go build hello.go
./hello

# 결과
hello world
```

`strace`를 사용해서 프로그램이 어떤 시스템 콜을 호출하는 지 확인할 수 있다.( -o 옵션은 파일로 저장)

```bash
# 결과 출력 및 hello.log에 저장
strace -o hello.log ./hello

# 시스템 콜 확인(log 파일)
cat hello.log
```

`strace` 출력 각각의 줄이 1개의 시스템 콜 호출로 마지막 문장은 `write(1, “hello world\n”, 12) = 12` ****가 나왔다. (write 시스템 콜 호출)

Python으로 확인해보자.

```python
# hello.py
print("hello world")
```

```bash
# 파일 권한 
chmod +x hello.py

# 결과 출력 및 hello.py.log에 저장
strace -o hello.py.log python3 ./hello.py

# 시스템 콜 확인(log 파일)
cat hello.py.log
```

Go언어로 했을 때와 동일하게 마지막은 write 시스템콜 호출로 끝나는데 전체결과를 확인해보면 스크립트형 언어다 보니 확실히 Go언어보다 많은 시스템 콜을 호출하는 것을 확인할 수 있었다.(많은 문장 출력)

**시스템 콜을 처리하는 시간 비율**

```bash
sar -P 0 1 1
```

`sar` : CPU가 실행하고 있는 명령 비율 확인

-P 0 : CPU 코어 0이 어떤 종류 처리를 하는지 확인

1 : 1초

1 : 1번 데이터 수집

해당 명령어를 수행하면 다양한 필드의 값들을 표시한다. 

- %user + %nice : 사용자 모드에서 프로세스를 실행하는 시간 비율
- %system : 커널이 시스템 콜을 처리한 시간 비율
- %idle : 아무 것도 하지 않는 idel 상태 비율

taskset 명령어를 이용해서 inf-loop.py(무한루프) 프로그램을 CPU 0에서 동작해보자.

```python
import os

# 부모 프로세스의 프로세스 ID 얻기
while True:
	os.getppid()
```

```bash
taskset -c 0 python3 ./inf-loop.py &

sar -P 0 1 1
```

해당 명령어를 수행하면 %user(48%)와 %system(52%)이 대략 절반씩 차지하며 %idle은 0이 된 것을 확인할 수 있다. 결국 끊임없이 시스템 콜을 호출해서 %system이 큰 비율을 차지함을 알 수 있다. 

(user → kernel → user → kernel …)

### 모니터링, 경고 알림 및 대시보드

시스템이 예상한 대로 동작하는지 확인하려면 `sar` 명령어를 비롯한 도구를 사용해서 시스템 통계 정보를 수집하는 것이 중요하다. 

- 수집, 관리하는 구조를 `모니터링(monitoring)` 이라고 부른다.(프로메테우스, 데이터독..)
- 계속해서 사람이 통계 정보를 직접 확인하는 것은 어렵기 때문에 일반적으로 어떤 상태가 정상인지 미리 정의해두고 이상이 발생하면 관리자에게 알려주는 `알림(alert)` 기능을 모니터링 도구와 함께 사용한다.
- 수집한 데이터를 가시화해서 확인 가능한 `대시보드` 기능도 함께 사용한다.(Grafana Dashboard .. )

현재 EATceed 프로젝트를 진행하고 있어 모니터링 기능을 추가하려고 하는데, 모니터링 기능에 기반이 되는 `sar` 명령어를 학습해서 기본적인 이해가 높아진 것 같다.